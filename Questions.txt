1) What can we do on a computer than we can’t do on a printed board?
	We can:
		- Provide a vast network of players to choose from (via the internet)
		- Enable tweaking of difficulty
		- Provide multiple games played at once


2) What is a computerized opponent? Remember, not everyone is an expert.  
	A computerized opponent is some code which appears to play the game like a human player

What are its objectives?  
	Its objective is to win the game

What characteristics should it possess?
	-It should be able to play quickly and react to the human playing
	-Ideally it should demonstrate the ability to plan

Do we need an opponent or opponents?
	We would like to have oppononents to reflect multiple skill levels

3) What design choices exist for the Interface components? 

Colour?

Font? 

Dimensions of Windows? 

Rescale-ability? 

Scroll Bars? ....


4) What are the advantages and disadvantages of using a visual GUI construction tool?
	Advantages:
	-Immediate feedback when adjusting the size of components
	-Don't need to use code to specify size of every single component
	Disadvantages:
	-New tool to learn (potential learning curve)
	-May limit ability to have dynamic GUI
	-May miss out on some programmatic 'tricks'
How would you integrate the usage of such a tool into a development process?
	Have a 'rough' GUI built quickly to interface with the code.
	Time permitting, polish it up for the final product.

5) What does exception handling mean in a GUI system?

Can we achieve consistent (error) messaging to the user now that we are using two components (Ruby and GTK2)?

What is the impact of the Ruby/GTK2 interface on exception handling?

6) Do we require a command-line interface for debugging purposes????? The answer is yes by the way – please explain why.
	Yes.  What we deliver to the screen via the GUI and what we actually have underlying in the code can be different.
	To make sure, we will debug with a command line interface.

7) What components do Connect 4 and “OTTO and TOOT” have in common?
	Almost all components are the same.
	The only difference is the win condition, instead of OOOO, it is OTTO.

How do we take advantage of this commonality in our OO design?
	We will design small reusable, switchable components to only switch out the win condition.
	This way, we can reuse all the code to implement a slight change in functionality.

How do we construct our design to “allow it to be efficiently and effectively extended”?

8) What is Model-View-Controller (MVC this was discussed in CMPE 300 and CMPUT301)? Illustrate how you have utilized this idea in your solution. That is, use it!
	Model View Controller is a design pattern that separates the entire application into three distinct parts:
	Model - Contains the application data and all of its business logic
	View - User facing representation of the data
	Controller - mediates input from the View to the Model, and vice versa.

9) Different articles describe MVC differently; are you using pattern Composite?, Observer?, Strategy? 

How are your views and controllers organized? What is your working definition of MVC?
We use one of each:
	- Our Model will be the Game Board object, containing all the data of the game state, as well as prevent illegal moves.
	- Our View will be the UI object that interfaces with Gtk2
	- Our Controller will be the Game Instance object, linking actions from the view to interact with the Game Board object.

10) Namespaces – are they required for this problem? Fully explain your answer!
	Namespaces can be required for this problem to properly separate different code pieces that may have the same name.


11) Iterators – are they required for this problem? Fully explain your answer!


12) What components of the Ruby exception hierarchy are applicable to this problem, etc? Consider the content of the library at: http://c2.com/cgi/wiki?ExceptionPatterns Which are applicable to this problem? Illustrate your answer.